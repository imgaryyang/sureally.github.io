---
layout: article
title: 2020-06-05-《实战Java高并发程序设计》阅读笔记
date: 2020/6/5 20:58
categories: [阅读笔记, 实战Java高并发程序设计]
tags: [阅读笔记, 实战Java高并发程序设计]
root-path: ../..
---

# 第1章 走入并行世界

## 何去何从的并行世界

## 你必须知道的几个概念

- 同步和异步

- 并发和并行

  > 并发侧重于多个任务交替运行，而多个任务之间也可能还是串行的。而并行是真正意义上的同时执行。但是，在多个CPU的场景下，并发的最终效果可能和并行是一样的。

- 临界区

- 阻塞和非阻塞

- 死锁、饥饿和活锁

  > 死锁：
  >
  > 饥饿：某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。如，线程优先级较低。
  >
  > 活锁：线程主动将资源释放给他人使用，导致资源不断的在两个线程间跳动，而没有一个线程可以同时拿到所有的资源正常执行。

## 并发级别

根据控制并发的策略，可以把并发的级别分为阻塞、无饥饿、无障碍、无锁、无等待几种。

- 阻塞

  > 可以看作是悲观策略，对于临界区的访问是阻塞的。

- 无饥饿

  > 对于非公平锁来锁，允许高优先级的线程插队，这样有可能导致低优先级的线程产生饥饿。而公平锁，就不会。

- 无障碍

  > 可以看作是乐观策略。认为对临界区的是不会发生冲突的，如果发生冲突，应该进行回滚然后阻塞执行。

- 无锁

  > 在无锁的调用中，一个典型的特点是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程可以胜出，不至于全军覆没。但是，对于竞争失败的线程，它们不断重试，直到自己获胜，如果运气不好就会出现类似饥饿的现象。

- 无等待

  > 无等待则在无锁的基础上更进一步扩展。它要求所有的线程必须在有限步内完成，这样就不会引起饥饿问题。
  >
  > 典型的无等待结构是 RCU(Read Copy Update)，基本思想是，对数据的读可以不加控制，读线程是无等待的；但是在写线程的时候，先取得原始数据的副本，接着只修改副本数据，修改完成后，在合适的时机回写数据。

## 有关并行的两个重要定律

## 回到Java：JMM

Java的内存模型（JMM）的关键技术点都是围绕着多线程的原子性、可见行以及有序性来建立的。

- 原子性

  > 一个操作是不可中断的，即使多个线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰。

- 可见性

  > 指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。

- 有序性

  > 有序性问题的原因是程序在执行时，可能会进行指令重排，重排后的指令未必与原始指令的顺序一致。
  >
  > 指令重排的基本前提是：保证串行语义的一致性。
  >
  > 之所以需要做指令重排，就是为了尽量少地中断流水线。

# 第2章 Java并行程序基础

## 有关线程你必须知道的事

##  初始线程：线程的基本操作

## volatile 与 Java 内存模型

## 分门别类的管理：线程组

## 驻守后台：守护线程（daemon）

## 先做重要的事：线程优先级

## 线程安全的概念与关键词 synchronized

## 程序中的幽灵：隐蔽的错误

# 第三章JDK并发包

## 多线程的团队合作：同步控制

### 关键词 synchronized 的功能扩展：重入锁

ReentrantLock 重入锁可以完全替代 synchronized。但是，在JDK6.0之后，synchronzied做了大量的优化，使得两者的性能差距不大。

1. 中断响应

   对于synchronized来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得锁继续执行，要么保持等待。

   而，使用ReentrantLock，提供另外一种可能，就是线程可以被中断，即在等待锁的过程中，程序可以根据需求取消对锁的请求。`ReentrantLock#lockInterruptibly()` 这是个可以对中断进行响应的锁申请动作，即在等待锁的过程中，可以响应中断。

2. 锁申请等待限时

   `ReentrantLock#tryLock` 带参数可以限时等待锁。如果不带限时参数，则是，当前线程尝试获得锁，如果锁未被其他线程占用，则申请锁成功，并立即返回True。如果锁被其他线程占用，则当前线程不会进行等待。而是立即返回false。

3. 公平锁

   `public ReentrantLock(boolean fair)` 提供了构造函数，可以选择是否是公平锁。公平锁实现成本较高，性能较为低下，因为公平锁需要系统维护一个有序队列。

   根据系统的调度而言，一个线程会倾向于再次获取已经持有的锁。

> 对于ReentrantLock的几个重要方法，总结如下
>
> - `lock()`：获得锁，如果锁已经被占用，则等待
> - `lockInterruptibly()`：获得锁，但优先响应中断
> - `tryLock()`：尝试获得锁，如果成功，则返回true，失败返回false。该方法不等待，立即返回
> - `tryLock(long time, TimeUnit unit)`：在给定时间内尝试获得锁.
> - `unlock()`：释放锁

就重入锁的实现来看，主要集中在Java层面。在重入锁的实现中，主要包含三个要素:

- 原子状态。原子状态使用CAS操作来存储当前锁的状态，判断锁是否已经被别的线程持有了
- 等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作。
- 阻塞原语`park()`和`unpark()`，用来挂起和恢复线程。没有获得锁的线程将会被挂起。

### 重入锁的好搭档：`Condition`

Condition的作用与 wait方法和notify方法的作用大致相当。而 `Condition`是与重入锁`ReentractLock`相关联的。利用Condition对象，可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行。

与Object.wait()方法和notify()方法一样，当线程使用Condition.await()方法时，要求线程持有相关的重入锁，在Condition.await()方法调用后，这个线程会释放这把锁。同理，在Condition.signal() 方法调用时，也要求线程先获得相关的锁。在signal()方法调用后，系统会从当前Condition对象的等待队列中唤醒一个线程。一旦线程被唤醒，它会重新尝试获得与之绑定的重入锁，一旦成功获取，就可以继续执行了。因此，**在signal() 方法调用后，一般需要释放相关的锁。**

### 允许多个线程同时访问：信号量(semaphore)

信号量可以为多线程协作提供了更为强大的控制方法。

信号量是对锁的扩展。无论是内部锁 synchronized 还是重入锁 ReentrantLock，一次只允许一个线程访问一个资源，而信号量却可以指定多个线程，同时访问某一个资源。

构造信号量对象时，必须指定信号量的准入数，即同时能申请多少个许可。每个线程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。

### 读写锁

`ReadWriteLock` 是JDK5中提供的读写分离锁。读写分离锁可以有效地帮助减少锁竞争，提升系统性能。

![image-20200608230409185](/Users/shushu/Library/Application Support/typora-user-images/image-20200608230409185.png)

### 倒计数器：CountDownLatch

`CountDownLatch`是一个非常实用的多线程控制工具类。

### 循环栅栏：CyclicBarrier

`CyclicBarrier`是另外一种多线程并发控制工具。和CountDownLatch非常类似，可以实现线程间的计数等待，但是功能比CountDownLatch更加复杂和强大。

CyclicBarrier 比 CountDownLatch 略微强大一些，它可以接受一个参数作为 BarrierAction，即当计数器一次计数完成后，系统会执行的动作，如下构造函数，

```java
public CyclicBarrier(int parties, Runnable barrierAction) // parties 计数总数，barrierAction 执行动作
```

在 CyclicBarrier 等待的过程中，BrokenBarrierException 是其特有异常。一旦遇到此异常，则表示当前的 CyclicBarrier已经破损，可能系统已经无法等待所有的线程到齐了。

### 线程阻塞工具类：LockSupport

LockSupport 是一个非常方便实用的线程阻塞工具：可以在线程内任意位置让线程阻塞。

> 和 `Thread.suspend()` 方法相比，弥补了由于 `resume()` 方法发生导致线程无法继续执行的情况
>
> 和`Object.wait()`方法相比，不需要先获得某个对象的锁，也不会抛出 interruptException异常。

LockSupport使用了类似信号量的机制。它为每一个线程准备了一个许可，如果许可可用，那么 park() 方法会立即返回，并且消费这个许可(也就是将许可变为不可用)，如果许可不可用，就会阻塞，而 unpark() 方法则就是让一个许可变为可用(但是和信号量不同的是，许可不能累加，你不可能拥有超过一个许可，它永远只有一个)。

![image-20200608234606982](/Users/shushu/Library/Application Support/typora-user-images/image-20200608234606982.png)

除了有定时阻塞的功能以外，LockSupport.park() 方法还能支持中断影响。但是和其他接收中断的函数不一样，LockSupport.park() 方法不会抛出 InterruptedException 异常，只会默默返回，但是可以从 Thread.interrupted() 等方法中获得中断标记。

### Guava 和 RateLimiter 限流

这里将介绍 Guava中提供的一款限流工具 RateLimiter，RateLimiter是一款限流工具。

一般化的限流算法有两种：漏桶算法和令牌桶算法。

> - 漏桶算法
>
>   利用一个缓冲区，当有请求进入系统时，无论请求的速率如何，都先在缓存区保存，然后以固定的流速流出缓存区进行处理。
>
>   其特点是：无论外部请求压力如何，漏桶算法总是以固定的流速处理数据。漏桶的容积和流出速率是该算法的两个重要参数。
>
> - 令牌桶算法
>
>   是一种反向的漏桶算法。在令牌桶中存放的不再是请求，而是令牌。处理请求只有拿到令牌后，才能对请求进行处理。如果没有令牌，那么处理程序要么丢弃请求，那么等待可用的令牌。为了限制流速，该算法在每个单位时间产生一定量的令牌存入桶中。
>
>   通常，桶的容量是有限的，当令牌没有被消耗时，只能累积有限单位时间内的令牌数量。

RateLimiter采用了令牌桶算法，但是不保证公平(that it does not guarantee fairness)。

- `acquire()`：阻塞
- `tryAcquire()`：未拿到许可会丢弃请求，注意是判断返回值。



## 线程复用：线程池

控制和管理多线程的原因

- 创建和管理线程需要花费时间
- 线程本身需要占用内存，大量的线程回收会给GC带来很大压力。

### 什么是线程池

### 不要重新发明轮子：JDK对线程池的支持

JDK提供了一套Executor框架，可以有效进行线程控制，其本质就是一个线程池。

Executors 工厂类提供了一系列方便的方法

- newFixedThreadPool()

  该方法返回一个固定线程数量的线程池。**注意：其使用了无界任务队列，当任务提交非常频繁的时候，该队列可以迅速，从而耗尽系统资源**

- newSingleThreadExecutor()

  只是简单将 newFixedThreadPool() 线程池线程数量设置为1。**所以还是存在风险**

- newCachedThreadPool()

  corePoolSize 为0，maximumPoolSize 无穷大的线程池，在没有任务时，该线程池无线程。

  若无空闲线程，则将任务加入 SynchronousQueue队列，而 SynchronousQueue作为一种直接提交的队列，总是迫使线程池增加新的线程执行任务。**所以还是存在风险**

- newSingleThreadScheduledExecutor()

- newScheduledThreadPool()：该方法返回一个ScheduledExecutorService对象，但是线程池可以指定线程的数量。

这里newScheduledThreadPool() 返回的对象可以根据时间需要对线程进行调度，和其他几个线程池不同，ScheduledExecutorService并不一定会立即安排执行任务，起到是计划任务的作用，会在指定的时间，对任务进行调度。其内部方法 scheduleAtFixedRate() 和 scheduleWithFixedDelay() 会对任务进行周期性的调度，但是有点区别

- scheduleAtFixedRate：任务调度的频率是一定的。以上一个任务开始执行时间为起点，在之后的period时间调度下一次任务。

  > Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is executions will commence after initialDelay then initialDelay+period, then initialDelay + 2 * period, and so on. If any execution of the task encounters an exception, subsequent executions are suppressed. Otherwise, the task will only terminate via cancellation or termination of the executor. If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.

- scheduleWithFixedDelay：是以上一个任务结束后，在经过delay时间进行任务调度。

  > Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next. If any execution of the task encounters an exception, subsequent executions are suppressed. Otherwise, the task will only terminate via cancellation or termination of the executor.

**注意：如果任务遇到异常，那么后续所有子任务都会停止调度，因此，必须保证异常被及时处理，为周期性任务的稳定调度提供条件**

**另外：使用完线程池后，记得关闭线程池**

### 刨根问底：核心线程池的内部实现

对于newFixedThreadPool()/newSingleThreadExecutor()/newCachedThreadPool() 方法来说，内部实现均使用了 ThreadPoolExecutor类。

该类的构造函数：

```java
    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     * @param unit the time unit for the {@code keepAliveTime} argument
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:<br>
     *         {@code corePoolSize < 0}<br>
     *         {@code keepAliveTime < 0}<br>
     *         {@code maximumPoolSize <= 0}<br>
     *         {@code maximumPoolSize < corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }

```

- corePoolSize：指定了线程池中的核心线程数量
- maximumPoolSize：指定了线程池中的最大线程数量
- keepAliveTime：当线程池数量超过了 corePoolSize 时，多余的空闲线程的存活时间，即超过了 corePoolSize的空闲线程，在多长时间内会被销毁
- unit：keepAliveTime的单位
- workQueue：任务队列，被提交但尚未被执行的任务
- threadFactory：线程工厂，用于创建线程，一般用默认的即可
- hadlder：拒绝策略。

重点说明，workQueue和handler两个参数

- workQueue

  指被提交但未执行的任务队列，仅用于存放 Runnable对象，根据功能分类，使用以下几种BlockingQueue接口

  - 直接提交的队列：SynchronousQueue

    SynchronousQueue是一个特殊的BlockingQueue，**其没有容量**，每一个插入操作都要等待一个相应的删除操作，反之每个删除操作都需要等待相应的插入操作。

    如果使用SynchronousQueue，则提交的任务不会真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程则创建新的线程，如果到达最大线程则执行拒绝策略。

  - 有界的任务队列：ArrayBlockingQueue

    ArrayBlockingQueue类的构造函数必须带一个容量参数，表示该队列的最大容量。

    线程池的实际线程数小于corePoolSize，则优先创建新的线程；

    若大于corePoolSize，则加入等待队列；

    若等待队列已满，无法加入，则总线程数不大于maximumPoolSize的前提， 创建新的进程执行任务；

    若大于maximumPoolSize则执行拒绝策略。

  - 无界的任务队列：LinkedBlockingQueue

    与有界任务队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。

    当有新任务的时候，系统的线程数小于corePoolSize时，线程池会生成新的线程；达到corePoolSize，就不会继续增加了，任务直接进入到队列等待，一直增加，直至耗尽系统内存。

  - 优先任务队列：PriorityBlockingQueue

    优先任务队列是带有执行优先级的队列；

    特殊的无界队列，可以根据任务自身的优先级顺序先后执行。

ThreadPoolExecutor 线程池的核心调度代码

>```java
>public void execute(Runnable command) {
>    if (command == null)
>        throw new NullPointerException();
>    /*
>     * Proceed in 3 steps:
>     *
>     * 1. If fewer than corePoolSize threads are running, try to
>     * start a new thread with the given command as its first
>     * task.  The call to addWorker atomically checks runState and
>     * workerCount, and so prevents false alarms that would add
>     * threads when it shouldn't, by returning false.
>     *
>     * 2. If a task can be successfully queued, then we still need
>     * to double-check whether we should have added a thread
>     * (because existing ones died since last checking) or that
>     * the pool shut down since entry into this method. So we
>     * recheck state and if necessary roll back the enqueuing if
>     * stopped, or start a new thread if there are none.
>     *
>     * 3. If we cannot queue task, then we try to add a new
>     * thread.  If it fails, we know we are shut down or saturated
>     * and so reject the task.
>     */
>    int c = ctl.get();
>  	// 当前线程池的线程总数
>    if (workerCountOf(c) < corePoolSize) {
>        if (addWorker(command, true))
>            return;
>        c = ctl.get();
>    }
>    if (isRunning(c) && workQueue.offer(command)) {
>        int recheck = ctl.get();
>        if (! isRunning(recheck) && remove(command))
>            reject(command);
>        else if (workerCountOf(recheck) == 0)
>            addWorker(null, false);
>    }
>    else if (!addWorker(command, false))
>        reject(command);
>}
>```

### 超负载了怎么办：拒绝策略

JDK内置了四种拒绝策略

- AbortPolicy

  该策略会直接抛出异常，阻止系统正常工作

- CallerRunsPolicy

  只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。

- DiscardOldestPolicy

  该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。

- DiscardPolicy

  该策略默默地丢弃无法处理的任务，不予任何处理。**如果允许任务丢失，这个是推荐的策略**。

以上内置策略均实现了 RejectedExecutionHandler接口，如果以上无法满足实际应用的需要，可以自己扩展实现。

### 自定义线程创建：ThreadFactory

ThreadFactory是一个接口，只有一个方法用来创建线程。

```java
Thread newThread(Runnable r);
```

使用自定义 ThreadFactory，可以跟踪线程池究竟在何时创建了多少线程，也可以自定义线程的名称、组以及优先级等信息。甚至可以任性的将所有线程设置为守护线程。

比如：如果将所有线程都设置为守护线程，这样当主线程退出后，就会强制销毁线程池。

### 我的应用我做主：扩展线程池

可以对ThreadPoolExecutor进行扩展来，监控每个任务执行的开始时间和结束时间，或者一些其他功能。

ThreadPoolExecutor提供了三个接口来对线程池进行控制。

```java
// 任务执行前
protected void beforeExecute(Thread t, Runnable r) { }

// 任务执行后
protected void afterExecute(Runnable r, Throwable t) { }

// 线程池销毁时
protected void terminated() { }
```





## 不要重复发明轮子：JDK的并发容器



## 使用JMH进行性能测试

# 锁的优化和注意事项