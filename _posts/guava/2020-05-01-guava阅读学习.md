---
layout: article
title: 2020-05-01-guava阅读学习
date: 2020/5/1 21:28
categories: Java
tags:
root-path: ../..
---

# Guava 简介


[Guava官方教程(中文版)]: https://ifeve.com/google-guava/
# base utilities

##  Preconditions

Guava在Preconditions类中提供了若干前置条件判断的实用方法。每种方法都有三个变种

- 没有额外参数：抛出的异常没有错误消息
- 有一个Object对象作为额外参数：抛出的异常使用Object.toString()作为错误消息
- 有一个String对象作为额外参数，并且有一组任意数量的附加Object对象：类似于printf，考虑GWT的兼容性和效率，只支持%s指示符。

| 方法声明                                            | 描述 | 检查失败时抛出的异常 | 备注                                                         |
| --------------------------------------------------- | ---- | -------------------- | ------------------------------------------------------------ |
| checkArguement(boolean)                             |      |                      |                                                              |
| checkNotNull(T)                                     |      |                      |                                                              |
| checkState(boolean)                                 |      |                      |                                                              |
| checkElementIndex(int index, int size)              |      |                      | 索引值常用来查找列表、字符串或数组中的元素，如 List.get(int), String.charAt(int) |
| checkPositionIndex(int index, int size)             |      |                      | 位置值和位置范围常用来截取列表、字符串或数组。List.subList(int, int), String.substring(int) |
| checkPosisitonIndexes(int start, int end, int size) |      |                      |                                                              |

相比于Apache Commons提供的类似方法，把Guava中的Preconditions作为首选的理由有

- 在静态导入后，Guava方法非常清晰。如，checkNotNull清楚的描述做了什么，会抛出什么异常
- checkNotNull直接返回检查的参数，可以在构造函数中保持字段的单行赋值风格：this.field = checkNotNull(field)
- 简单的、参数可变的printf风格异常信息。

【建议】*在编码时，如果某个值有多重的前置条件，把它们放到不同的行，这样有助于在调试时定位。此外，把每个前置条件放到不同的行，也可以帮助编写清晰和有用的错误消息。*

## 常见Object方法

- equals

  当一个对象中的字段可以为null时，实现Object.equals方法会很痛苦，因为不得不分别对它们进行null检查。使用`Objects.equal`帮助你执行null敏感的equals判断，从而避免抛出NullPointerException。【JDK7中已经引入该方法，实现是一样的】

- hashCode

  用对象的所有字段作散列 hash 运算应当更简单。Guava的[`Objects.hashCode(Object...)`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/base/Objects.html#hashCode(java.lang.Object...))会对传入的字段序列计算出合理的、顺序敏感的散列值。你可以使用Objects.hashCode(field1, field2, …, fieldn)来代替手动计算散列值。

  *注意：JDK7引入的Objects类提供了一样的方法*`*Objects.hash(Object...)*`

- toString

  好的toString方法在调试时是无价之宝，但是编写toString方法有时候却很痛苦。使用`MoreObjects.toStringHelper(Object)`可以轻松编写有用的toString方法。

  ```java
  class ObjectsTest {
    @Test
    public void toStringTest() {
      @Data
      @AllArgsConstructor
      class Inner {
        String field1;
        String field2;
      }
      Inner sample = new Inner("a", null);
      assertEquals("Inner(field1=a, field2=null)", sample.toString());
      assertEquals("Inner{x=1}", MoreObjects.toStringHelper(sample).add("x", "1").toString());
      assertEquals("sample{x=1}", MoreObjects.toStringHelper("sample").add("x", "1").toString());
      assertEquals("Inner{x=1}", MoreObjects.toStringHelper(Inner.class).add("x", "1").toString());
    }
  }
  ```

- compare/compareTo

  一般对java对象需要自定义排序的情况，需要实现一个比较器`Comparator`，或者直接实现Comparable接口有时也伤不起。

  <pre><code class="java"> public int compareTo(Foo that) {
     return ComparisonChain.start()
         .compare(this.aString, that.aString)// aString 不能为null
         .compare(this.anInt, that.anInt)
         .compare(this.anEnum, that.anEnum, Ordering.natural().nullsLast())
         .result();
   }
</code></pre>

  需要注意的是：

  - ComparisonChain是不可变的，所以需要链式调用。
  - 为了优化效率，在第一个非0的compare处会停止，所以尽量将不同的放在前面

## fluent风格比较器



## Throwables

异常传播，有时候想把捕获到的异常再次抛出。这种情况通常发生在Error或RuntimeException被捕获的时候，此时并没有想捕获它们，但是声明捕获Throwable和Exception的时候，也包括了Error或RuntimeException，Guava提供了若干方法，来判断异常类型并且重新传播异常。

| 方法                                                         | 描述                                            |      |
| ------------------------------------------------------------ | ----------------------------------------------- | ---- |
| `void propagateIfPossible( Throwable throwable, Class<X> declaredType)` | Throwable类型为X, Error或RuntimeException才抛出 |      |

Guava还提供了几个方法，用于研究异常的原因

- `Throwable getRootCause(Throwable throwable)`
- `List<Throwable> getCausalChain(Throwable throwable)`
- `String getStackTraceAsString(Throwable throwable)`

# Strings

## Strings.lenientFormat

guava提供的这个方法和jdk提供的string.format相比，效率几乎有一个数量级的提升。

效率提升的关键就是实现方式了，lenienttFormat使用的StringBuilder进行构建，String.format应用了Print效率不高。

```java
class StringsTest {

  @Test
  public void lenientBenchTest() {
    String template = "%s %s %s";
    String a = "Test";
    String b = "lenient";
    String c = "bench";

    int times = 1000000;
    Stopwatch stopwatch = Stopwatch.createUnstarted();
    stopwatch.start();
    for (int i = 0; i < times; i++) {
      usingLenient(template, a, b, c);
    }
    stopwatch.stop();
    // 213 ms
    System.out.println(times + "次 using lenient cost " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms");

    stopwatch.reset();
    stopwatch.start();
    for (int i = 0; i < times; i++) {
      usingStringFormat(template, a, b, c);
    }
    stopwatch.stop();
    // 1580ms
    System.out.println(times + "次 using stringFormat cost " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms");
  }


  private void usingLenient(String template, String... args) {
    Strings.lenientFormat(template, args);
  }

  private void usingStringFormat(String template, String... args) {
    String.format(template, args);
  }
}
```

