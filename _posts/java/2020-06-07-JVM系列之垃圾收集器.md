---
layout: article
title: JVM系列之垃圾收集器
date: 2020/6/7 22:57
categories: [Java, JVM, GC]
tags: [Java, JVM, GC]
root-path: ../..
---

# 前言

垃圾收集器的目标
- 最大吞吐量：GC线程占用CPU的耗时。
- 最小暂停时间：GC导致的程序的停顿时间。

上述两个目标是相互矛盾的。

# CMS GC收集器

## 步骤

1. 初始标记 Initial-mark（STW）

   该阶段进行可达性分析，标记GC ROOT能**直接关联**的对象。注意是直接关联，间接关联的对象在下一阶段标记。

2. 并发标记 Concurrent-mark

   并发标记阶段是和用户线程并发执行的过程。该阶段进行GC ROOT TRACING，在第一阶段被暂停的线程重新开始开始运行。由前一阶段标记过的对象出发，所有可到达的对象都在本阶段标记。

3. 并发预处理

   > 新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。

   CMS就采用了这样的方式，**在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。**

   此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。

   > CMSMaxAbortablePrecleanTime: 为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark.
   >
   > CMSScavengeBeforeRemark：用来保证Remark前强制进行一次Minor GC

4. 重新标记Remark（STW）

   暂停所有用户线程，重新扫描堆中的对象(包括老年代/年轻代)，进行可达性分析，标记活着的对象。

   > 因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。

   特别需要注意一点，**这个阶段是以新生代中对象为根来判断对象是否存活的**。

![image-20200607230642694](/assets/images/java/image-20200607230642694.png)

5. 并发清理

进行并发的垃圾清理。

## 更多思考

### Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？

不可行。

![image-20200607231005234](/assets/images/java/image-20200607231005234.png)

如果仅扫描老年代中对象，即以老年代中对象为根，判断对象是否存在引用，上图中，对象A因为引用存在新生代中，它在Remark阶段就不会被修正标记为可达，GC时会被错误回收。 新生代对象持有老年代中对象的引用，这种情况称为**“跨代引用”**。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活，包括图中灰色的不可达对象。

灰色对象已经不可达，但仍然需要扫描的原因：**新生代GC和老年代的GC是各自分开独立进行的**，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。

### **JVM是如何避免Minor GC时扫描全堆的？**

> 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。

![image-20200607231139782](/assets/images/java/image-20200607231139782.png)

**卡表**的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。

### 小杰

总结来说，**CMS的设计聚焦在获取最短的时延**，为此它“不遗余力”地做了很多工作，

- 尽量让应用程序和GC线程并发
- 增加可中断的并发预清理阶段
- 引入卡表等

虽然这些操作**牺牲了一定吞吐量但获得了更短的回收停顿时间**。

CMS 在老年代GC使用的标记清除算法，好处是速度快，但是会产生许多空间碎片，然后在长时间运行后会造成Full GC退化为Serial Old GC，使用标记整理算法，会进行整理压缩，但是STW一般时间很长。

## 优化（**ParNew+CMS，CMS失败时Serial Old替补**）

### 案例1：Major GC 和 Minor GC频繁

可能原因：MajorGC发生在新生代区域，MajorGC频繁可能是因为新生代分配的内存太小，导致对象都存在了MinorGC，此时引发MinorGC。

#### 问题分析：

1. 分析新生代中到老年代的对象存活次数是不是默认的15次，

   如果小于15，则有可能是因为JVM系列-（七）中引发FullGC的原因5，即新生代的eden区与S1往S2复制的时候，S2区域太小，导致对象直接复制到老年代，致使老年代内存不足，从而导致MinorGC。

2. 查看MajorGC前后老年代的占用内存大小，差距是不是很大

   例MajorGC前占用内存为2G，之后占用内存为0.3G，则说明有大量对象在一次MajorGC中被消除。

#### 解决方案

增加新生代大小

### 案例2：请求高峰发生GC，导致服务可用性下降

查看日志分析原因，查看项目在哪个回收阶段时间过长。假设为Remark阶段时间过长(因为Remark阶段是STW)

#### 问题分析：

新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。CMS就采用了这样的方式，**在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。**此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。

除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。 根据GC日志红色标记2处显示，可中断的并发预清理执行了5.35s，超过了设置的5s被中断，期间没有等到Minor GC ，所以Remark时新生代中仍然有很多对象。

#### 解决方案：

对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。

### 发生STW的GC

#### 问题分析

（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。本次优化目标是降低单次STW回收停顿时间，提高可用性。

![img](/assets/images/java/v2-35996eb96137168701ed5c0bae94b4b2_1440w.jpg)

#### 优化方案

什么时候会出发STW的Full GC？

> 1. Perm空间不足/Metaspace Space(元空间)使用达到MaxMetaspaceSize阈值；
>
>    说明：1）JDK 8开始Perm区完全消失，取而代之的是元空间，元空间是直接存在内存中的，不在JVM中
>
>    2）如果配置了CMS，并且Metaspace Space使用量达到MetaspaceSize阈值是触发CMS GC；
>
> 2. CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；
>
> 3. 统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；
>
> 4. 主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。
>
>    ![img](/assets/images/java/v2-c0ab237140cc301511ffe2aeca7ac919_b.jpg)

可以逐一分析

> 排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。
>
> 排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。
>
> 排除原因4：因为当时没有相关命令执行。
>
> 锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。

找到问题后解决办法：

>1. 通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。
>2. CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。

由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。

#### 优化结果

调整参数后，服务不再有Perm区扩容导致的STW GC发生。

#### 小结

对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。

### Jstat

jstat -gc 看到的包括CMS GC 和FULL GC 的次数，一次CMS GC 会使 jstat -gc 里面的Full gc 次数增长2 ，一次FULL GC 会使 jstat -gc 里面的Full gc 次数增长1.

**FGC误解主要来自最常用的ParNew+CMS组合** ，很多人误解FullGC可能是受到 jstat 命令结果的影响，因为发生CMS GC时，FGC也会增大（但是会+2，这是因为CMS GC的初始化标记和重新标记都会完全的STW，从而FGC的值会+2）。但是，事实上这并没有发生FullGC。 **jstat命令结果中的FGC并不表示就一定发生了FullGC** ，很有可能只是发生了CMS GC而已。

# G1 垃圾收集器

如果你的堆内存大于4G（有些博客推荐8G以下使用CMS）的话，那么G1会是要考虑使用的收集器。它是为了更好支持大于4G堆内存在JDK 7 u4引入的。G1收集器把堆分成多个区域，大小从1MB到32MB，并使用多个后台线程来扫描这些区域，优先会扫描最多垃圾的区域，这就是它名称的由来，垃圾优先Garbage First。

如果在后台线程完成扫描之前堆空间耗光的话，才会进行STW收集。它另外一个优点是它在处理的同时会整理压缩堆空间，相比CMS只会在完全STW收集的时候才会这么做。

使用过大的堆内存在过去几年是存在争议的，很多开发者从单个JVM分解成使用多个JVM的微服务（micro-service）和基于组件的架构。其他一些因素像分离程序组件、简化部署和避免重新加载类到内存的考虑也促进了这样的分离。

除了这些因素，最大的因素当然是避免在STW收集时JVM用户线程停滞时间过长，如果你使用了很大的堆内存的话就可能出现这种情况。另外，像Docker那样的容器技术让你可以在一台物理机器上轻松部署多个应用也加速了这种趋势。

# 参考

-[JVM系列-（八）CMS与G1](https://zhuanlan.zhihu.com/p/52544311)

